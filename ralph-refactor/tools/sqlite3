#!/usr/bin/env python3
import sys
import sqlite3
import os

def main():
    if len(sys.argv) < 2:
        print('Usage: sqlite3 <db_path> [SQL]')
        sys.exit(1)

    db_path = sys.argv[1]
    if not db_path:
        print('Missing db path')
        sys.exit(1)

    sql = ' '.join(sys.argv[2:]) if len(sys.argv) >= 3 else sys.stdin.read()

    db_dir = os.path.dirname(db_path)
    if db_dir and not os.path.exists(db_dir):
        try:
            os.makedirs(db_dir, exist_ok=True)
        except Exception:
            pass

    conn = sqlite3.connect(db_path)
    conn.isolation_level = None
    cur = conn.cursor()

    statements = [s.strip() for s in sql.split(';') if s.strip()]

    try:
        for stmt in statements:
            stmt_upper = stmt.lstrip().upper()
            try:
                cur.execute(stmt)
            except sqlite3.Error as e:
                try:
                    conn.executescript(stmt)
                except sqlite3.Error as e2:
                    err_str = str(e2).lower()
                    if 'already exists' not in err_str and 'duplicate column' not in err_str:
                        print(f"sqlite3 error: {e2}", file=sys.stderr)
                        print(f"  statement: {stmt[:100]}...", file=sys.stderr)
                    continue

            if (stmt_upper.startswith('SELECT') or stmt_upper.startswith('PRAGMA') or 'RETURNING' in stmt_upper):
                try:
                    rows = cur.fetchall()
                    for row in rows:
                        def fmt(item):
                            if item is None:
                                return 'NULL'
                            return str(item)
                        print('|'.join(fmt(item) for item in row))
                except sqlite3.Error:
                    pass
        conn.commit()
    finally:
        conn.close()

if __name__ == '__main__':
    main()

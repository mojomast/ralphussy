#!/usr/bin/env python3
import sys
import sqlite3
import os

def main():
    if len(sys.argv) < 2:
        print('Usage: sqlite3 <db_path> [SQL]')
        sys.exit(1)

    db_path = sys.argv[1]
    if not db_path:
        print('Missing db path')
        sys.exit(1)

    # Read SQL either from args (joined) or stdin
    if len(sys.argv) >= 3:
        sql = ' '.join(sys.argv[2:])
    else:
        sql = sys.stdin.read()

    # Ensure directory exists
    db_dir = os.path.dirname(db_path)
    if db_dir and not os.path.exists(db_dir):
        try:
            os.makedirs(db_dir, exist_ok=True)
        except Exception:
            pass

    conn = sqlite3.connect(db_path)
    conn.isolation_level = None  # allow explicit BEGIN/COMMIT
    cur = conn.cursor()

    # Split statements by semicolon for handling SELECT outputs
    statements = [s.strip() for s in sql.split(';') if s.strip()]

    try:
        for stmt in statements:
            # Normalize leading keyword
            stmt_upper = stmt.lstrip().upper()
            try:
                cur.execute(stmt)
            except sqlite3.Error:
                # Try executescript for multi-statement blocks
                try:
                    conn.executescript(stmt)
                except sqlite3.Error:
                    continue

            # If statement is a query or contains RETURNING, fetch and print rows
            if (stmt_upper.startswith('SELECT') or stmt_upper.startswith('PRAGMA') or 'RETURNING' in stmt_upper):
                try:
                    rows = cur.fetchall()
                    for row in rows:
                        def fmt(item):
                            if item is None:
                                return 'NULL'
                            return str(item)
                        print('|'.join(fmt(item) for item in row))
                except sqlite3.Error:
                    # Nothing to fetch
                    pass
        conn.commit()
    finally:
        conn.close()

if __name__ == '__main__':
    main()
